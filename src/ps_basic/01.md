## 문제해결
1.문제를 읽고 이해한다.  
2.문제를 익숙한 용어로 재정의 한다.  
3.어떻게 해결할지 계획을 세운다.  
4.계획을 검증한다.  
5.프로그램으로 구현한다.  
6.어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.  
## 추상화
추상화란 현실 세계의 개념을 우리가 다루기 쉬운 수학적/전산학적 개념으로 옮겨 표현하는 과정이다.  
현실 세계의 개념들은 너무 복잡하기 때문에, 현실 세계를 다루기 위해서는 어느 정도 현실의 본질만을 남기고
축약하여 다루기 쉽게 표현해야 한다.  
이런 과정을 추상화라고 부르며, 우리에게 익숙한 문제해결 도구들을 문제에 적용할 수 있는 계기가 된다. 
## 문제해결전략
- 직관과 체계적인 접근  
문제 해결 전략에서 가장 먼저 강조해야 할 것은 문제와 답의 구조에 대한 직관이다.  
직관으로 이를 파악하기 힘든 문제에 경우 아래의 질문들을 통해 문제 해결에 접근한다.  
##체계적인 접근을 위한 질문들  
1.비슷한 문제를 풀어본 적이 있는가?  
2.단순한 방법에서 시작할 수 있는가?  
3.내가 문제를 푸는 과정을 수식화할 수 있는가?  
4.문제를 단순화할 수 없는가?  
5.그림으로 그려볼수 있는가?  
6.수식으로 표현할 수 있는가?  
7.문제를 분해할 수 있는가?  
8.뒤에서부터 생각해서 문제를 풀 수 있는가?  
9.순서를 강제화할 수 있는가?  
10.특정 형태의 답만을 고려할 수 있는가?
## 좋은 코드의 중요성
#### 좋은 코드를 짜기 위한 원칙  
1.간결한 코드를 작성하기  
대표적인 예로 전역변수의 사용이 있다. 일반적인 프로그래밍에서 전역변수의 사용은 
코드의 흐름 파악을 방해할 수 있기에 사용을 지양한다.  
하지만 문제 해결에서 작성하는 코드는 비교적 구조가 단순하고, 각 변수를 읽고 쓰는
부분이 명확하기 때문에 전역 변수를 사용할 경우 실 보다 득이 더 많다.   
2.적극적으로 코드를 재사용하기  
간결한 코드 작성을 위한 가장 직접적인 방법은 코드를 모듈화하는 것이다. 같은 코드가
반복된다면 이들을 함수나 클래스로 분리해 재사용하는 것이다. 같은 코드가 세 번 이상
등장한다면 항상 해당 코드를 함수로 분리해 재사용한다는 기본 원칙을 만드는 것이 좋다.  
3.표준 라이브러리 활용  
언어의 문자열, 동적배열, 스택, 큐, 리스트 등의 자료구조, 그리고 정렬 등의 표준적인
알고리즘 구현 사용법을 반드시 잘 알아 둔다.  
4.항상 같은 형태로 프로그램을 작성하기  
5.일관적이고 명료한 명명법 사용하기  
```java
boolean judge(int y, int x,  int cy, int cx, int cr){};
-->
boolean isInsideCircle(int y, int x,  int cy, int cx, int cr){};
```
6.모든 자료를 정규화해서 저장하기  
같은 자료를 두 가지 형태로 저장하지 않는다.  
ex) 시간 : UTC, 문자열 : UTF-8  
이상적으로는 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나,
외부에서 자료를 입력받자마자 정규화를 수행하는 것이 좋다.  
7.코드와 데이터를 분리하기  
날짜를 다루는 프로그램을 작성하는데, 날짜를 출력할 때 월을 숫자가 아니라 영문
이름으로 출력해야 하는 경우, 많이 하는 실수는 다음과 같이 열두 줄짜리 함수를 짜는 것이다.  
```java
String getMonthName(int month){
if(month==1) return "January";
if(month==2) return "February";
.
.
.
if(month==12) return "December";
}

```
코드와 논리적으로 상관 없는 데이터는 가능한 분리하는 것이 가장 좋다.  
예를 들어 각 월의 영어 이름을 다음과 같은 테이블로 만들 수 있다.  
```java
String monthName[] = {"January","Februrary",..."December"};
```
## 자주 하는 실수
1.산술 오버플로우  
2.배열 범위 밖 원소에 접근  
3.일관되지 않은 범위 표현 방식 사용하기  
4.off-by-one 오류  
계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을
모두 가리킨다.  
ex)  
100미터 담장에 10미터 간격으로 기둥을 세운다. 기둥이 몇 개 필요한가?  
정답은 10개가 아니라 11개이다.  
  -->담장의 길이가 0미터라도 기둥은 하나 세워야한다.
  
int[] a 가 주어질 때 a[i] 부터 a[j] 까지의 평균을 구할 경우 합을 얼마로 나눠야 하는가?  
j-i 가 아니라 j-i+1 이다.  
-->a[1] 부터 a[1] 의 평균을 구할 땐 0이 아니라 1로 나눠야 한다.  
5.컴파일러가 잡아주지 못하는 상수 오타  
6.스택 오버플로우  
프로그램의 실행 중 call stack 이 오버플로우 해서 프로그램이 강제종료되는 경우는
흔하다.  
대게 스택 오버플로우는 재귀 호출의 길이가 너무 깊어져서 발생하기 때문에 재귀 호출을
사용할 경우에는 이를 주의한다.  
스택의 최대 크기는 컴파일이나 실행시에 설정할 수 있고 기본 값이 언어나 아키텍처 등에 
따라 매우 다르기 때문에 사용하는 환경의 스택 허용량에 대해 알아 둘 필요가 있다.  
7.다차원 배열 인덱스 순서 바꿔 쓰기  
8.잘못된 비교 함수 작성  
__< 연산자의 성질__  
-a<a 는 항상 거짓이다. -> 비반사성(irreflexivity)  
-a<b 가 참이면 b>a 는 거짓이다. -> 비대칭성(asymmetry)  
-a<b 가 참이고 b<c 가 참이면 a<c 이다. -> 전이성(transitivity)
-a<b 와 b<a 가 모두 거짓이면 a==b 이다. a==b 이고 b==c 이면 a==c 이다.  
->상등 관계의 전이성
(transitivity of equivalnace)  
9.최소, 최대 예외 잘못 다루기  
10.연산자 우선순위 잘못 쓰기  
11.너무 느린 입출력 방식 선택  
12.변수 초기화 문제  
이전 입력에서 사용한 전역 변수 값을 초기화하지 않고 그대로 사용하는 것이 흔한 실수이다.  
이런 실수를 방지하는 방법으로는 예제 입력 파일을 두 번 반복해 쓰는 것이다.  

